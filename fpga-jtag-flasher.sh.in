#!/bin/sh

# fpga-jtag-flasher.sh - FPGA JTAG Flash Programming Wrapper
# Wrapper script for xc3sprog with enhanced functionality for FPGA programming
# Generated by CMake from fpga-jtag-flasher.sh.in

set -e  # Exit on any error

# Configuration (set by CMake)
XC3SPROG_BIN="@CMAKE_INSTALL_PREFIX@/bin/xc3sprog"
BSCAN_PATH="@CMAKE_INSTALL_PREFIX@/share/xc3sprog/bscan_spi"
XPC2_LOADER="@CMAKE_INSTALL_PREFIX@/bin/xc3sprog-xpc2.sh"

# Fallback to system paths if installed files not found
if [ ! -x "$XC3SPROG_BIN" ]; then
    XC3SPROG_BIN="/usr/bin/xc3sprog"
fi

if [ ! -d "$BSCAN_PATH" ]; then
    BSCAN_PATH="/usr/share/xc3sprog/bscan_spi"
fi

if [ ! -x "$XPC2_LOADER" ]; then
    XPC2_LOADER="/usr/local/bin/xc3sprog-xpc2.sh"
fi

DEFAULT_CABLE="gpiod_creator"
DEFAULT_POSITION=0
VERBOSE=0
USE_SUDO=0  # Flag to determine if sudo is needed

# Helper function to conditionally use sudo
# Handles: buildroot (root user), Pi OS (non-root), missing sudo
run_xc3sprog() {
    # Check if already running as root
    if [ "$(id -u)" = "0" ]; then
        # Already root (buildroot or sudo su), run directly
        "$@"
    # Check if sudo is available
    elif ! command -v sudo >/dev/null 2>&1; then
        # sudo not available (minimal buildroot?), try direct
        # This may fail if not root and permissions not set
        "$@"
    # Check if XPC2 cable requires sudo
    elif [ $USE_SUDO -eq 1 ]; then
        # Non-root user with XPC2 cable - use sudo
        sudo "$@"
    else
        # Non-root user with GPIO cable - run directly (no USB access needed)
        "$@"
    fi
}

# USB stick configuration
# Use /tmp to avoid potential /mnt permission/I/O issues
USB_MOUNT_POINT="/tmp/micropanel-usb"
USB_MOUNTED_BY_SCRIPT=0

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions (using printf for POSIX compatibility)
# All log output goes to stderr to avoid mixing with function return values
log_info() {
    printf "${BLUE}[INFO]${NC} %s\n" "$1" >&2
}

log_success() {
    printf "${GREEN}[SUCCESS]${NC} %s\n" "$1" >&2
}

log_warning() {
    printf "${YELLOW}[WARNING]${NC} %s\n" "$1" >&2
}

log_error() {
    printf "${RED}[ERROR]${NC} %s\n" "$1" >&2
}

# Detect USB stick device (dynamic detection of removable media)
detect_usb_stick() {
    log_info "Checking for USB stick..."

    # Dynamically detect all block devices
    local usb_device=""

    # Check all /dev/sd* block devices
    for block_dev in /sys/block/sd*; do
        if [ ! -e "$block_dev" ]; then
            continue
        fi

        local dev_name=$(basename "$block_dev")
        local removable=$(cat "$block_dev/removable" 2>/dev/null || echo "0")

        # Check if it's removable (USB sticks have removable=1)
        if [ "$removable" = "1" ]; then
            # Found a removable device, now find its first partition
            if [ -e "/dev/${dev_name}1" ]; then
                usb_device="/dev/${dev_name}1"
            elif [ -e "/dev/${dev_name}" ]; then
                usb_device="/dev/${dev_name}"
            fi

            if [ -n "$usb_device" ]; then
                log_info "Found USB stick: $usb_device (removable)"
                if [ $VERBOSE -eq 1 ]; then
                    # Show additional device info
                    local size=$(cat "$block_dev/size" 2>/dev/null || echo "unknown")
                    local vendor=$(cat "$block_dev/device/vendor" 2>/dev/null | tr -d ' ' || echo "unknown")
                    local model=$(cat "$block_dev/device/model" 2>/dev/null | tr -d ' ' || echo "unknown")
                    log_info "Device: $vendor $model, Size: $size blocks"
                fi
                echo "$usb_device"
                return 0
            fi
        fi
    done

    if [ $VERBOSE -eq 1 ]; then
        log_info "No USB stick detected"
    fi
    return 1
}

# Detect filesystem type
detect_filesystem() {
    local device="$1"

    # Try to detect filesystem using blkid (most reliable)
    if command -v blkid >/dev/null 2>&1; then
        local fstype=$(sudo blkid -o value -s TYPE "$device" 2>/dev/null)
        if [ -n "$fstype" ]; then
            echo "$fstype"
            return 0
        fi
    fi

    # Fallback: try file command
    if command -v file >/dev/null 2>&1; then
        local file_output=$(sudo file -s "$device" 2>/dev/null)
        if echo "$file_output" | grep -qi "FAT"; then
            echo "vfat"
            return 0
        elif echo "$file_output" | grep -qi "NTFS"; then
            echo "ntfs-3g"
            return 0
        elif echo "$file_output" | grep -qi "exFAT"; then
            echo "exfat"
            return 0
        fi
    fi

    # Default: assume vfat (most common for USB sticks)
    echo "vfat"
    return 0
}

# Mount USB stick if not already mounted
mount_usb_stick() {
    local device="$1"

    # Check if already mounted
    if mount | grep -q "$device"; then
        local existing_mount=$(mount | grep "$device" | awk '{print $3}' | head -1)
        log_info "USB stick already mounted at: $existing_mount"
        echo "$existing_mount"
        USB_MOUNTED_BY_SCRIPT=0
        return 0
    fi

    # Create mount point if it doesn't exist
    if [ ! -d "$USB_MOUNT_POINT" ]; then
        log_info "Creating mount point: $USB_MOUNT_POINT"
        if ! sudo mkdir -p "$USB_MOUNT_POINT"; then
            log_error "Failed to create mount point: $USB_MOUNT_POINT"
            return 1
        fi
    fi

    # Detect filesystem type
    local fstype=$(detect_filesystem "$device")
    log_info "Detected filesystem type: $fstype"

    # Mount the USB stick with appropriate filesystem type
    log_info "Mounting USB stick to: $USB_MOUNT_POINT"

    # Try mounting with detected filesystem type
    if sudo mount -t "$fstype" "$device" "$USB_MOUNT_POINT" 2>/dev/null; then
        log_success "USB stick mounted successfully (type: $fstype)"
        USB_MOUNTED_BY_SCRIPT=1
        echo "$USB_MOUNT_POINT"
        return 0
    else
        # If specific type fails, try auto-detection
        log_info "Trying auto-detection..."
        if sudo mount "$device" "$USB_MOUNT_POINT" 2>/dev/null; then
            log_success "USB stick mounted successfully (auto-detected)"
            USB_MOUNTED_BY_SCRIPT=1
            echo "$USB_MOUNT_POINT"
            return 0
        else
            log_error "Failed to mount USB stick"
            if [ $VERBOSE -eq 1 ]; then
                log_error "Try installing required packages:"
                log_error "  For NTFS: sudo apt-get install ntfs-3g"
                log_error "  For exFAT: sudo apt-get install exfat-fuse exfat-utils"
            fi
            return 1
        fi
    fi
}

# Unmount USB stick - always unmount if mount point is in use
unmount_usb_stick() {
    # Always try to unmount if mount point exists and is mounted
    if [ -d "$USB_MOUNT_POINT" ] && mount | grep -q "$USB_MOUNT_POINT"; then
        log_info "Unmounting USB stick from: $USB_MOUNT_POINT"
        if sudo umount "$USB_MOUNT_POINT" 2>/dev/null; then
            log_success "USB stick unmounted successfully"
            USB_MOUNTED_BY_SCRIPT=0
            return 0
        else
            if [ $VERBOSE -eq 1 ]; then
                log_warning "Failed to unmount USB stick (may still be in use)"
            fi
            return 1
        fi
    fi
    return 0
}

# Search for file on USB stick (recursive)
find_file_on_usb() {
    local filename="$1"
    local mount_point="$2"

    log_info "Searching for file '$filename' on USB stick..."

    # Use find to search recursively for the exact filename
    local found_file=$(find "$mount_point" -type f -name "$filename" 2>/dev/null | head -1)

    if [ -n "$found_file" ] && [ -f "$found_file" ]; then
        log_success "Found file on USB stick: $found_file"
        echo "$found_file"
        return 0
    else
        if [ $VERBOSE -eq 1 ]; then
            log_info "File '$filename' not found on USB stick"
        fi
        return 1
    fi
}

# Resolve flash file path with USB stick priority
resolve_flash_file() {
    local default_path="$1"
    local final_file="$default_path"

    # Extract just the filename from the full path
    local filename=$(basename "$default_path")

    log_info "Resolving flash file: $filename"
    log_info "Default path: $default_path"

    # Try to detect and mount USB stick
    local usb_device
    if usb_device=$(detect_usb_stick); then
        log_info "USB stick detected: $usb_device"

        # Try to mount the USB stick
        local mount_point
        if mount_point=$(mount_usb_stick "$usb_device"); then
            log_info "USB stick mounted at: $mount_point"

            # Search for the file on USB stick
            local usb_file
            if usb_file=$(find_file_on_usb "$filename" "$mount_point"); then
                log_success "Using file from USB stick (PRIORITY): $usb_file"
                final_file="$usb_file"
            else
                log_warning "File not found on USB stick, falling back to internal path"
                log_info "Using internal file: $default_path"
            fi
        else
            log_warning "Failed to mount USB stick, using internal path"
            log_info "Using internal file: $default_path"
        fi
    else
        if [ $VERBOSE -eq 1 ]; then
            log_info "No USB stick detected, using internal path"
        fi
        log_info "Using internal file: $default_path"
    fi

    # Validate final file exists
    if [ ! -f "$final_file" ]; then
        log_error "Flash file not found: $final_file"
        return 1
    fi

    echo "$final_file"
    return 0
}

# Show usage information
show_usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] COMMAND

FPGA JTAG Flash Programming Wrapper for xc3sprog

Installation paths:
  xc3sprog: $XC3SPROG_BIN
  bscan files: $BSCAN_PATH

COMMANDS:
    --info                      Show FPGA and SPI flash information
    --flash=FILE               Flash bitstream file to SPI flash
    --dump=FILE                Dump flash contents to file (requires --size)
    --help                     Show this help message

OPTIONS:
    --cable=CABLE              JTAG cable type (default: $DEFAULT_CABLE)
                               Common cables: gpiod_creator (Pi GPIO 3.3V)
                                              xpc2 (Platform Cable USB II 1.8V/3.3V)
    --xpc-firmware=FILE        XPC2 firmware file (auto-enables --cable=xpc2)
                               Loads firmware to Waveshare Platform Cable USB
    --position=POS             JTAG chain position (default: $DEFAULT_POSITION)
    --bscan=FILE               Custom bscan bitstream file
    --size=BYTES               Size in bytes for dump operation
    --skipbitstream            Skip bitstream loading (use with --flash or --info)
    --verbose                  Enable verbose output
    --dry-run                  Show commands without executing

EXAMPLES:
    # 3.3V targets with Pi GPIO (default, no --xpc-firmware needed)
    $(basename "$0") --info
    $(basename "$0") --flash=/path/to/fpga.bin

    # 1.8V targets with Platform Cable USB II (Waveshare)
    $(basename "$0") --xpc-firmware=/home/pi/firmware/xusb_xp2.hex --info
    $(basename "$0") --xpc-firmware=/home/pi/firmware/xusb_xp2.hex --flash=/path/to/fpga.bin
    $(basename "$0") --xpc-firmware=/home/pi/firmware/xusb_xp2.hex --dump=/tmp/backup.bin --size=4194304

    # Other examples
    $(basename "$0") --info --skipbitstream
    $(basename "$0") --dump=/home/pi/backup.bin --size=4194304
    $(basename "$0") --dump=/home/pi/backup.bin --size=4194304 --verbose
    $(basename "$0") --flash=/path/to/fpga.bin --verbose --dry-run

COMMON DUMP SIZES:
    64 KB:   --size=65536
    1 MB:    --size=1048576
    4 MB:    --size=4194304  (S25FL132K full flash)
    8 MB:    --size=8388608

SUPPORTED FPGA DEVICES:
    Auto-detected based on JTAG ID. Common bscan files available:
    - XC7S50T (xc7s50csga324-1.bit)
    - XC6SLX series (xc6slx16_cs324.bit, xc6slx45-fg484.bit, etc.)
    - XC3S series (xc3s250e_godil.bit, xc3s400an.bit, etc.)

EOF
}

# Parse FPGA device from IDCODE
get_fpga_device() {
    local idcode="$1"
    case "$idcode" in
        "0x0362f093") echo "XC7S50T" ;;
        "0x03632093"|"0x13632093") echo "XC7A75T" ;;
        "0x0362D093") echo "XC7A35T" ;;
        "0x0362C093") echo "XC7A50T" ;;
        "0x04250093") echo "XC6SLX16" ;;
        "0x04286093") echo "XC6SLX45" ;;
        "0x0428c093") echo "XC6SLX75T" ;;
        "0x01414093") echo "XC3S250E" ;;
        "0x0141c093") echo "XC3S400AN" ;;
        "0x01428093") echo "XC3S500E" ;;
        *) echo "UNKNOWN($idcode)" ;;
    esac
}

# Find appropriate bscan file for device
find_bscan_file() {
    local device="$1"
    local bscan_file=""
    
    case "$device" in
        "XC7S50T")     bscan_file="$BSCAN_PATH/xc7s50csga324-1.bit" ;;
        "XC7A75T")     bscan_file="$BSCAN_PATH/xc7a75t-2fgg484.bit" ;;
        "XC7A35T"|"XC7A50T")
                       bscan_file="$BSCAN_PATH/xc7s50csga324-1.bit" ;;
        "XC6SLX16")    bscan_file="$BSCAN_PATH/xc6slx16_cs324.bit" ;;
        "XC6SLX45")    bscan_file="$BSCAN_PATH/xc6slx45-fg484.bit" ;;
        "XC6SLX75T")   bscan_file="$BSCAN_PATH/xc6slx75-t-fg484.bit" ;;
        "XC3S250E")    bscan_file="$BSCAN_PATH/xc3s250e_godil.bit" ;;
        "XC3S400AN")   bscan_file="$BSCAN_PATH/xc3s400an.bit" ;;
        "XC3S500E")    bscan_file="$BSCAN_PATH/xc3s500e_godil.bit" ;;
        *)
            log_warning "No specific bscan file found for device $device"
            # Try to find a generic one
            bscan_file=$(find "$BSCAN_PATH" -name "*.bit" | head -1)
            ;;
    esac
    
    if [ -f "$bscan_file" ]; then
        echo "$bscan_file"
    else
        log_error "Bscan file not found: $bscan_file"
        return 1
    fi
}

# Validate and check cable availability
validate_cable() {
    local cable="$1"

    case "$cable" in
        gpiod_creator|gpiod_voice)
            # GPIO cables - always available on Pi4
            return 0
            ;;
        xpc|xpc2|xpc_internal)
            # USB Platform Cable - check if device is connected
            if lsusb -d 03fd:0008 >/dev/null 2>&1 || lsusb -d 03fd:0013 >/dev/null 2>&1; then
                return 0
            else
                log_error "Platform Cable USB not found (cable=$cable)"
                log_error "Please connect Xilinx/Waveshare Platform Cable USB"
                log_error "Run 'lsusb' to check if device 03fd:0008 or 03fd:0013 is present"
                return 1
            fi
            ;;
        ftdi|ft2232|ft4232h|ft232h)
            # FTDI cables - check if any FTDI device present
            if lsusb -d 0403: >/dev/null 2>&1; then
                return 0
            else
                log_error "FTDI cable not found (cable=$cable)"
                log_error "Please connect FTDI-based JTAG cable"
                return 1
            fi
            ;;
        *)
            # Unknown cable - let xc3sprog handle it
            log_warning "Unknown cable type: $cable (will try anyway)"
            return 0
            ;;
    esac
}

# Parse SPI flash device from JEDEC ID
get_flash_device() {
    local jedec="$1"
    # Normalize the JEDEC string (handle different spacing formats)
    local normalized=$(echo "$jedec" | sed 's/0x/ 0x/g' | tr -s ' ')

    case "$normalized" in
        # Spansion/Cypress S25FL-K series (Manufacturer ID: 0x01, Type: 0x40)
        *"0140 0x15"*|*"01 40 0x15"*) echo "S25FL116K" ;;
        *"0140 0x16"*|*"01 40 0x16"*) echo "S25FL132K" ;;
        *"0140 0x17"*|*"01 40 0x17"*) echo "S25FL164K" ;;
        # Spansion/Cypress S25FL series (Manufacturer ID: 0x01, Type: 0x60)
        *"0160 0x16"*|*"01 60 0x16"*) echo "S25FL032" ;;
        *"0160 0x17"*|*"01 60 0x17"*) echo "S25FL064" ;;
        *"0160 0x18"*|*"01 60 0x18"*) echo "S25FL128" ;;
        # ISSI
        *"9d60 0x18"*|*"9d 60 0x18"*) echo "IS25LP128" ;;
        # Winbond
        *"ef40 0x18"*|*"ef 40 0x18"*) echo "W25Q128" ;;
        # Micron/Numonyx
        *"2020 0x18"*|*"20 20 0x18"*) echo "M25P128" ;;
        # Macronix
        *"c220 0x18"*|*"c2 20 0x18"*) echo "MX25L128" ;;
        *) echo "UNKNOWN($jedec)" ;;
    esac
}

# Get FPGA and flash information
get_info() {
    local cable="$1"
    local position="$2"
    local bscan_file="$3"
    local skip_bitstream="$4"
    
    log_info "Please Wait...reading jtag chain info"

    # Check if xc3sprog exists and is executable
    if [ ! -x "$XC3SPROG_BIN" ]; then
        log_error "xc3sprog not found at $XC3SPROG_BIN"
        return 1
    fi

    # Validate cable is available
    if ! validate_cable "$cable"; then
        return 1
    fi

    # First, try to detect FPGA device without bscan
    local cmd_detect="$XC3SPROG_BIN -c $cable -p $position"
    local output_detect
    
    if [ $VERBOSE -eq 1 ]; then
        log_info "Running device detection: $cmd_detect"
    fi

    # Use sudo only if USE_SUDO flag is set (for xpc2 cable)
    if ! output_detect=$(run_xc3sprog $cmd_detect 2>&1); then
        if [ $VERBOSE -eq 1 ]; then
            log_error "Command failed: $cmd_detect"
            log_error "Output: $output_detect"
        fi
        log_error "Failed to communicate with FPGA during device detection"
        echo "Failed!!"
        return 1
    fi
    
    if [ $VERBOSE -eq 1 ]; then
        log_info "Device detection output:"
        echo "$output_detect"
    fi
    
    # Extract IDCODE from detection
    local idcode
    idcode=$(echo "$output_detect" | grep -o "IDCODE: 0x[0-9a-fA-F]*" | cut -d: -f2 | tr -d ' ')
    
    if [ -z "$idcode" ]; then
        log_error "Could not detect FPGA device"
        if [ $VERBOSE -eq 1 ]; then
            log_error "IDCODE extraction failed from output:"
            echo "$output_detect"
        else
            log_info "Run with --verbose for more details"
        fi
        echo "Failed!!"
        return 1
    fi
    
    # Get device name
    local device
    device=$(get_fpga_device "$idcode")
    
    # CRITICAL: Check if we should skip bscan (flash detection)
    if [ "$skip_bitstream" = "1" ]; then
        log_info "Skipping bscan bitstream and flash detection (--skipbitstream specified)"
        log_success "IDCODE=$idcode : DEVICE=$device : FLASH=SKIPPED : CABLE=$cable"
        return 0
    fi
    
    # Now try with bscan for flash detection
    local cmd_flash="$XC3SPROG_BIN -c $cable -p $position"
    
    # Auto-select bscan file if not provided
    if [ -z "$bscan_file" ]; then
        log_info "Trying to auto-detect bscan file for $device..."
        if ! bscan_file=$(find_bscan_file "$device"); then
            log_warning "No bscan file found for $device, skipping flash detection"
            log_success "IDCODE=$idcode : DEVICE=$device : FLASH=NOT_DETECTED : CABLE=$cable"
            return 0
        fi
        log_info "Using bscan file: $bscan_file"
    fi
    
    if [ -n "$bscan_file" ]; then
        if [ ! -f "$bscan_file" ]; then
            log_error "Bscan file not found: $bscan_file"
            return 1
        fi
        cmd_flash="$cmd_flash -I$bscan_file"
    fi
    
    if [ $VERBOSE -eq 1 ]; then
        cmd_flash="$cmd_flash -v"
        log_info "Running flash detection: $cmd_flash"
    fi
    
    # Execute flash detection command
    local output_flash
    if ! output_flash=$(run_xc3sprog $cmd_flash 2>&1); then
        log_warning "Flash detection failed, but FPGA was detected"
        log_success "IDCODE=$idcode : DEVICE=$device : FLASH=DETECTION_FAILED : CABLE=$cable"
        return 0
    fi
    
    # Extract JEDEC ID if available
    local flash_jedec flash_device
    flash_jedec=$(echo "$output_flash" | grep "JEDEC:" | cut -d: -f2 | tr -s ' ' | sed 's/^ *//; s/ *$//')

    if [ -n "$flash_jedec" ]; then
        # JEDEC string is already properly formatted from xc3sprog
        flash_device=$(get_flash_device "$flash_jedec")
        log_success "IDCODE=$idcode : DEVICE=$device : FLASH=$flash_device : SPI-FLASH-JEDEC=$flash_jedec : CABLE=$cable"
    else
        log_warning "SPI flash not detected with bscan bitstream"
        log_success "IDCODE=$idcode : DEVICE=$device : FLASH=NOT_DETECTED : CABLE=$cable"
    fi
}

# Flash bitstream to SPI flash
flash_bitstream() {
    local cable="$1"
    local position="$2"
    local flash_file="$3"
    local skip_bitstream="$4"
    local dry_run="$5"

    # Resolve flash file with USB stick priority
    local resolved_file
    if ! resolved_file=$(resolve_flash_file "$flash_file"); then
        log_error "Failed to resolve flash file"
        unmount_usb_stick
        return 1
    fi

    # Use the resolved file (either from USB or internal)
    flash_file="$resolved_file"

    # Check if xc3sprog exists and is executable
    if [ ! -x "$XC3SPROG_BIN" ]; then
        log_error "xc3sprog not found at $XC3SPROG_BIN"
        unmount_usb_stick
        return 1
    fi

    log_info "Starting flash programming..."
    log_info "Flash file: $flash_file"
    log_info "File size: $(du -h "$flash_file" | cut -f1)"

    # First, detect the FPGA device (reuse existing logic)
    local cmd_detect="$XC3SPROG_BIN -c $cable -p $position"
    local output_detect

    if ! output_detect=$(run_xc3sprog $cmd_detect 2>&1); then
        log_error "Failed to detect FPGA device"
        unmount_usb_stick
        return 1
    fi

    # Extract IDCODE
    local idcode
    idcode=$(echo "$output_detect" | grep -o "IDCODE: 0x[0-9a-fA-F]*" | cut -d: -f2 | tr -d ' ')

    if [ -z "$idcode" ]; then
        log_error "Could not detect FPGA device"
        unmount_usb_stick
        return 1
    fi
    
    local device
    device=$(get_fpga_device "$idcode")
    log_info "Detected FPGA: $device ($idcode)"
    
    # Build flash command
    local cmd_flash="$XC3SPROG_BIN -c $cable"
    
    # Add bscan bitstream unless skipping
    if [ "$skip_bitstream" -eq 0 ]; then
        log_info "Loading bscan bitstream for SPI flash access..."
        
        # Auto-select bscan file
        local bscan_file
        if ! bscan_file=$(find_bscan_file "$device"); then
            log_error "No bscan file found for device $device"
            unmount_usb_stick
            return 1
        fi
        
        log_info "Using bscan file: $bscan_file"
        cmd_flash="$cmd_flash -I$bscan_file"
    else
        log_info "Skipping bscan bitstream (--skipbitstream specified)"
        cmd_flash="$cmd_flash -I"
    fi
    
    # Add flash programming parameters
    cmd_flash="$cmd_flash -p $position $flash_file:w:0:BIN"
    
    if [ $VERBOSE -eq 1 ]; then
        cmd_flash="$cmd_flash -v"
    fi
    
    log_info "Flash command: $cmd_flash"
    
    # Execute flash programming
    if [ "$dry_run" -eq 1 ]; then
        log_info "DRY RUN: Would execute: run_xc3sprog $cmd_flash"
        unmount_usb_stick
        return 0
    fi

    log_info "Programming flash... This may take several minutes."
    log_warning "Do NOT interrupt the process or power off the device!"

    local start_time=$(date +%s)
    local output_flash

    if ! output_flash=$(run_xc3sprog $cmd_flash 2>&1); then
        log_error "Flash programming failed!"
        log_error "Command output:"
        echo "$output_flash"
        unmount_usb_stick
        return 1
    fi

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Check for success indicators in output
    if echo "$output_flash" | grep -q "Verify: Success!"; then
        log_success "Flash programming completed successfully!"
        log_info "Programming time: ${duration}s"

        # Extract useful statistics if available
        if echo "$output_flash" | grep -q "Maximum erase time"; then
            local erase_time=$(echo "$output_flash" | grep "Maximum erase time" | head -1)
            log_info "Flash stats: $erase_time"
        fi

        # Unmount USB stick before returning
        unmount_usb_stick
        return 0
    else
        log_error "Flash programming may have failed - verification not found in output"
        if [ $VERBOSE -eq 1 ]; then
            log_error "Full output:"
            echo "$output_flash"
        else
            log_info "Run with --verbose for detailed output"
        fi
        unmount_usb_stick
        return 1
    fi
}

# Dump flash contents to file
dump_flash() {
    local cable="$1"
    local position="$2"
    local dump_file="$3"
    local dump_size="$4"
    local dry_run="$5"

    # Validate dump file path
    if [ -z "$dump_file" ]; then
        log_error "No dump file specified"
        return 1
    fi

    # Validate dump size
    if [ -z "$dump_size" ]; then
        log_error "No dump size specified. Use --size=BYTES"
        log_info "Common sizes: 64K=65536, 1M=1048576, 4M=4194304"
        return 1
    fi

    # Check if file already exists (don't overwrite by default)
    if [ -f "$dump_file" ] && [ "$dry_run" -eq 0 ]; then
        log_warning "Dump file already exists: $dump_file"
        log_info "File will be overwritten (using :R action)"
    fi

    # Check if xc3sprog exists and is executable
    if [ ! -x "$XC3SPROG_BIN" ]; then
        log_error "xc3sprog not found at $XC3SPROG_BIN"
        return 1
    fi

    log_info "Starting flash dump operation..."
    log_info "Output file: $dump_file"
    log_info "Dump size: $dump_size bytes"

    # First, detect the FPGA device
    local cmd_detect="$XC3SPROG_BIN -c $cable -p $position"
    local output_detect

    if ! output_detect=$(run_xc3sprog $cmd_detect 2>&1); then
        log_error "Failed to detect FPGA device"
        return 1
    fi

    # Extract IDCODE
    local idcode
    idcode=$(echo "$output_detect" | grep -o "IDCODE: 0x[0-9a-fA-F]*" | cut -d: -f2 | tr -d ' ')

    if [ -z "$idcode" ]; then
        log_error "Could not detect FPGA device"
        return 1
    fi

    local device
    device=$(get_fpga_device "$idcode")
    log_info "Detected FPGA: $device ($idcode)"

    # Build dump command
    log_info "Loading bscan bitstream for SPI flash access..."

    # Auto-select bscan file
    local bscan_file
    if ! bscan_file=$(find_bscan_file "$device"); then
        log_error "No bscan file found for device $device"
        return 1
    fi

    log_info "Using bscan file: $bscan_file"

    # Build the read command
    # Format: file.bin:R:offset:BIN:length
    local cmd_dump="$XC3SPROG_BIN -c $cable -I$bscan_file -p $position ${dump_file}:R:0:BIN:${dump_size}"

    if [ $VERBOSE -eq 1 ]; then
        cmd_dump="$cmd_dump -v"
    fi

    log_info "Dump command: $cmd_dump"

    # Execute dump command
    if [ $dry_run -eq 1 ]; then
        log_info "[DRY RUN] Would execute: $cmd_dump"
        return 0
    fi

    log_info "Reading flash memory (this may take several minutes)..."

    if run_xc3sprog $cmd_dump 2>&1; then
        # Verify the dump file was created and has correct size
        if [ -f "$dump_file" ]; then
            local actual_size=$(stat -c%s "$dump_file" 2>/dev/null || wc -c < "$dump_file")
            if [ "$actual_size" -eq "$dump_size" ]; then
                log_success "Flash dump completed successfully!"
                log_info "Dumped $dump_size bytes to: $dump_file"
                log_info "File size: $(du -h "$dump_file" | cut -f1)"
            else
                log_error "Dump size mismatch. Expected: $dump_size, Got: $actual_size"
                return 1
            fi
        else
            log_error "Dump file was not created"
            return 1
        fi
    else
        log_error "Flash dump failed"
        return 1
    fi
}

# Main function
main() {
    local command=""
    local cable="$DEFAULT_CABLE"
    local position="$DEFAULT_POSITION"
    local bscan_file=""
    local flash_file=""
    local dump_file=""
    local dump_size=""
    local skip_bitstream=0
    local dry_run=0
    local xpc_firmware=""

    # Parse command line arguments
    while [ $# -gt 0 ]; do
        case $1 in
            --info)
                command="info"
                shift
                ;;
            --flash=*)
                command="flash"
                flash_file="${1#*=}"
                shift
                ;;
            --dump=*)
                command="dump"
                dump_file="${1#*=}"
                shift
                ;;
            --size=*)
                dump_size="${1#*=}"
                shift
                ;;
            --cable=*)
                cable="${1#*=}"
                shift
                ;;
            --xpc-firmware=*)
                xpc_firmware="${1#*=}"
                # Auto-enable xpc2 cable when firmware is specified
                cable="xpc2"
                shift
                ;;
            --position=*)
                position="${1#*=}"
                shift
                ;;
            --bscan=*)
                bscan_file="${1#*=}"
                shift
                ;;
            --skipbitstream)
                skip_bitstream=1
                shift
                ;;
            --verbose)
                VERBOSE=1
                shift
                ;;
            --dry-run)
                dry_run=1
                shift
                ;;
            --debug)
                set -x
                shift
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Validate command
    if [ -z "$command" ]; then
        log_error "No command specified"
        show_usage
        exit 1
    fi

    # Load XPC2 firmware if specified
    if [ -n "$xpc_firmware" ]; then
        # XPC2 cable requires sudo for both firmware loading and xc3sprog access
        USE_SUDO=1

        if [ ! -f "$xpc_firmware" ]; then
            log_error "XPC firmware file not found: $xpc_firmware"
            exit 1
        fi

        if [ ! -x "$XPC2_LOADER" ]; then
            log_error "XPC2 firmware loader not found: $XPC2_LOADER"
            log_error "Please ensure xc3sprog-xpc2.sh is installed"
            exit 1
        fi

        # Determine if we need sudo for firmware loading
        # Same logic as run_xc3sprog: skip sudo if root or sudo unavailable
        local LOADER_CMD="$XPC2_LOADER"
        if [ "$(id -u)" != "0" ] && command -v sudo >/dev/null 2>&1; then
            LOADER_CMD="sudo $XPC2_LOADER"
        fi

        # Always log firmware loading (not just in verbose mode)
        log_info "Loading XPC2 firmware..."

        if [ $VERBOSE -eq 1 ]; then
            if ! $LOADER_CMD --xpc-firmware="$xpc_firmware" --verbose; then
                log_error "Failed to load XPC2 firmware"
                exit 1
            fi
        else
            if ! $LOADER_CMD --xpc-firmware="$xpc_firmware"; then
                log_error "Failed to load XPC2 firmware"
                exit 1
            fi
        fi
    fi

    # Execute command
    case "$command" in
        "info")
            if [ $VERBOSE -eq 1 ]; then
                log_info "Calling get_info with skip_bitstream=$skip_bitstream"
            fi
            get_info "$cable" "$position" "$bscan_file" "$skip_bitstream"
            ;;
        "flash")
            if [ -z "$flash_file" ]; then
                log_error "No flash file specified with --flash=FILE"
                exit 1
            fi
            flash_bitstream "$cable" "$position" "$flash_file" "$skip_bitstream" "$dry_run"
            ;;
        "dump")
            if [ -z "$dump_file" ]; then
                log_error "No dump file specified with --dump=FILE"
                exit 1
            fi
            if [ -z "$dump_size" ]; then
                log_error "No dump size specified with --size=BYTES"
                log_info "Common sizes: 64K=65536, 1M=1048576, 4M=4194304"
                exit 1
            fi
            dump_flash "$cable" "$position" "$dump_file" "$dump_size" "$dry_run"
            ;;
        *)
            log_error "Unknown command: $command"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
